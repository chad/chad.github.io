<!DOCTYPE html>
<!-- Generated by Audio Visualizer Build System -->
<!-- Build ID: 4513c5d4 -->
<!-- Title: sunday -->
<!-- Treatment: typewriter -->
<!-- Generated: 2025-10-17T21:20:03.022Z -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sunday - Audio Visualizer</title>

    <!-- Primary Meta Tags -->
    <meta name="title" content="sunday">
    <meta name="description" content="Interactive audio visualizer with adaptive music analysis. Click to play and experience sunday.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="">
    <meta property="og:title" content="sunday">
    <meta property="og:description" content="Interactive audio visualizer with adaptive music analysis. Click to play and experience sunday.">
    <meta property="og:image" content="preview.jpg">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Audio Visualizer">
    <meta property="og:audio" content="sunday.mp3">
    <meta property="og:audio:type" content="audio/mpeg">

    <!-- Twitter -->
    <meta property="twitter:card" content="player">
    <meta property="twitter:url" content="">
    <meta property="twitter:title" content="sunday">
    <meta property="twitter:description" content="Interactive audio visualizer with adaptive music analysis. Click to play and experience sunday.">
    <meta property="twitter:image" content="preview.jpg">
    <meta property="twitter:player" content="">
    <meta property="twitter:player:width" content="1200">
    <meta property="twitter:player:height" content="675">

    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            background: rgb(10, 15, 25);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #progressBar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 2px;
            background: rgba(100, 180, 200, 0.15);
            border-radius: 2px;
            overflow: hidden;
            opacity: 0.25;
            transition: opacity 0.5s ease;
            animation: subtlePulse 3s ease-in-out infinite;
        }

        @keyframes subtlePulse {
            0%, 100% {
                opacity: 0.25;
                box-shadow: 0 0 5px rgba(100, 180, 200, 0.2);
            }
            50% {
                opacity: 0.4;
                box-shadow: 0 0 15px rgba(100, 180, 200, 0.4);
            }
        }

        #progressBar:hover {
            opacity: 1 !important;
            height: 3px;
            animation: none;
        }

        #progressFill {
            height: 100%;
            background: linear-gradient(90deg,
                hsla(180, 60%, 60%, 0.6),
                hsla(200, 60%, 60%, 0.8));
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(100, 180, 200, 0.4);
        }

        canvas {
            cursor: none;
        }

        #clickOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(10, 15, 25, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            cursor: pointer;
            opacity: 1;
            transition: opacity 0.8s ease;
        }

        #clickOverlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #clickMessage {
            color: rgba(100, 180, 200, 0.9);
            font-size: 18px;
            font-weight: 300;
            letter-spacing: 3px;
            text-transform: lowercase;
            animation: softFade 2s ease-in-out infinite;
        }

        @keyframes softFade {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        #sundayText {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(40px, 10vw, 120px);
            font-weight: 100;
            text-transform: lowercase;
            z-index: 1500;
            pointer-events: none;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            
            letter-spacing: clamp(8px, 2vw, 25px);
            overflow: hidden;
            border-right: 2px solid rgba(100, 180, 200, 0.7);
            white-space: nowrap;
        
            opacity: 1;
            transition: opacity 2s ease-out;
        }

        #sundayText.fadeOut {
            opacity: 0;
        }

        #sundayText span {
            color: rgba(100, 180, 200, 0.15);
            text-shadow: 0 0 20px rgba(100, 180, 200, 0.1);
            opacity: 1;  /* Start visible for initial display */
            transition: opacity 2.5s ease-in-out;
        }

        /* Interaction prompts */
        .instructions {
            position: fixed;
            color: rgba(100, 180, 200, 0.6);  /* Increased from 0.4 to 0.6 */
            font-size: 13px;  /* Increased from 11px to 13px */
            font-weight: 300;
            letter-spacing: 1.5px;
            text-transform: lowercase;
            z-index: 2500;  /* Above click overlay (was 1500) */
            pointer-events: none;
            opacity: 1;
            transition: opacity 3s ease-out;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .instructions.fadeOut {
            opacity: 0;
        }

        #dragInstruction {
            bottom: 80px;
            left: 30px;
        }

        #moveInstruction {
            top: 30px;
            left: 30px;
        }

        #zoomInstruction {
            bottom: 80px;
            right: 30px;
        }

        #clickInstruction {
            top: 30px;
            right: 30px;
        }

        .instructions span {
            opacity: 0.6;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <div id="clickOverlay">
        <div id="clickMessage">click anywhere</div>
    </div>
    <div id="sundayText" data-treatment="typewriter">
        <span class="typewriter">sunday</span>
    </div>

    <!-- Interaction instructions -->
    <div id="dragInstruction" class="instructions">
        drag <span>→</span> paint particles
    </div>
    <div id="moveInstruction" class="instructions">
        move <span>→</span> sculpt sound
    </div>
    <div id="zoomInstruction" class="instructions">
        scroll <span>→</span> zoom
    </div>
    <div id="clickInstruction" class="instructions">
        click <span>→</span> create waves
    </div>

    <canvas id="canvas"></canvas>
    <audio id="audio" src="sunday.mp3"></audio>
    <div id="progressBar">
        <div id="progressFill"></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const audio = document.getElementById('audio');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const clickOverlay = document.getElementById('clickOverlay');
        const sundayText = document.getElementById('sundayText');
        const sundayLetters = sundayText.querySelectorAll('span');

        // Get all instruction elements
        const instructions = document.querySelectorAll('.instructions');

        // Sunday memory flashback system
        let sundayMemoryTriggered = [];  // Track which flashbacks have occurred
        let isFlashbackActive = false;   // Prevent overlapping flashbacks

        // Mouse tracking
        let mouseX = window.innerWidth / 2;
        let mouseY = window.innerHeight / 2;
        let mouseInfluence = 0;
        let lastMouseX = mouseX;
        let lastMouseY = mouseY;
        let isDragging = false;

        // Auto-pilot mode for when user is idle
        let lastUserInteraction = Date.now();
        let autoPilotActive = false;
        const IDLE_TIMEOUT = 15000;  // 15 seconds of no interaction
        let autoPilotState = {
            gesture: null,
            startTime: 0,
            startX: 0,
            startY: 0,
            targetX: 0,
            targetY: 0,
            duration: 0
        };

        // Interactive effects
        let clickWaves = [];
        let mouseTrail = [];  // Persistent trail of mouse movement
        let userCreatedParticles = [];  // Particles created by dragging

        // Setup canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Mouse move handler - creates trails, spawns particles, and controls audio
        window.addEventListener('mousemove', (e) => {
            resetAutoPilot();  // User interaction detected
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            mouseX = e.clientX;
            mouseY = e.clientY;
            mouseInfluence = 1;

            // Update audio filter based on mouse Y position (filter sweep)
            if (filterNode && audioContext) {
                // Y position controls filter frequency: top = bright (20kHz), bottom = dark (200Hz)
                const filterFreq = 20000 - (mouseY / canvas.height) * 19800 + 200;
                filterNode.frequency.setTargetAtTime(filterFreq, audioContext.currentTime, 0.05);

                // X position controls subtle echo/delay: left = dry, right = wet
                const delayMix = (mouseX / canvas.width) * 0.25;  // Max 25% wet
                const feedback = (mouseX / canvas.width) * 0.35;   // Max 35% feedback

                if (wetGain && feedbackGain) {
                    wetGain.gain.setTargetAtTime(delayMix, audioContext.currentTime, 0.1);
                    feedbackGain.gain.setTargetAtTime(feedback, audioContext.currentTime, 0.1);
                }
            }

            // Create LONG-LASTING persistent trail points
            if (isDragging || Math.random() < 0.25) {  // More frequent trails
                mouseTrail.push({
                    x: mouseX,
                    y: mouseY,
                    life: 3,  // heavy trails
                    hue: 180 + Math.random() * 40,
                    createdAt: Date.now()
                });
            }

            // When dragging, create PERMANENT particles along the path (no time limit!)
            if (isDragging && Math.random() < 0.5) {  // More particles
                const newParticle = new Particle();
                newParticle.x = mouseX + (Math.random() - 0.5) * 20;
                newParticle.baseX = newParticle.x;
                newParticle.y = mouseY + (Math.random() - 0.5) * 20;
                newParticle.baseY = newParticle.y;
                newParticle.userCreated = true;
                newParticle.permanent = true;  // Mark as permanent
                newParticle.birthTime = Date.now();
                userCreatedParticles.push(newParticle);
            }
        });

        // Mouse down - start dragging
        canvas.addEventListener('mousedown', (e) => {
            resetAutoPilot();  // User interaction detected
            if (e.button === 0) {  // Left click
                isDragging = true;
            }
        });

        // Mouse up - stop dragging, create ripple wave
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isDragging = false;
            }
        });

        // Click handler - Right click removes nearby particles (destructive)
        canvas.addEventListener('contextmenu', (e) => {
            resetAutoPilot();  // User interaction detected
            e.preventDefault();

            // Remove particles within radius
            const removeRadius = 150;
            particles = particles.filter(p => {
                const dx = p.baseX - e.clientX;
                const dy = p.baseY - e.clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist > removeRadius;
            });

            // Also remove user-created particles
            userCreatedParticles = userCreatedParticles.filter(p => {
                const dx = p.baseX - e.clientX;
                const dy = p.baseY - e.clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist > removeRadius;
            });

            // Create a visual "void" wave
            clickWaves.push({
                x: e.clientX,
                y: e.clientY,
                radius: 0,
                maxRadius: 200,
                alpha: 1,
                speed: 2,
                age: 0,
                isVoid: true  // Mark as destructive wave
            });
        });

        // Left click - create DRAMATIC additive ripple wave with multiple rings
        canvas.addEventListener('click', (e) => {
            resetAutoPilot();  // User interaction detected
            // Create primary wave
            clickWaves.push({
                x: e.clientX,
                y: e.clientY,
                radius: 0,
                maxRadius: 800 + Math.random() * 400,  // Much larger (was 500-800)
                alpha: 1.5,  // Brighter start (was 1)
                speed: 1.2 + Math.random() * 0.8,  // Faster (was 0.6-1.0)
                age: 0,
                isVoid: false,
                isPrimary: true
            });

            // Create secondary wave ring (delayed start)
            setTimeout(() => {
                clickWaves.push({
                    x: e.clientX,
                    y: e.clientY,
                    radius: 0,
                    maxRadius: 600 + Math.random() * 300,
                    alpha: 1.0,
                    speed: 0.8 + Math.random() * 0.4,
                    age: 0,
                    isVoid: false,
                    isPrimary: false
                });
            }, 150);

            // Create tertiary wave ring (more delayed)
            setTimeout(() => {
                clickWaves.push({
                    x: e.clientX,
                    y: e.clientY,
                    radius: 0,
                    maxRadius: 400 + Math.random() * 200,
                    alpha: 0.8,
                    speed: 0.5 + Math.random() * 0.3,
                    age: 0,
                    isVoid: false,
                    isPrimary: false
                });
            }, 300);

            // Trigger zoom pulse effect on click
            clickZoomPulse = 1.15;  // Zoom in slightly on click
        });

        // Resize handler
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Reinitialize particles with new canvas size
            initParticles();
        });

        // Audio setup with effects chain
        let audioContext, analyser, source, dataArray;
        let audioSetupComplete = false;

        // Audio effects nodes
        let filterNode, delayNode, feedbackGain, wetGain, dryGain;

        function setupAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 1024;  // Increased for more detail
                analyser.smoothingTimeConstant = 0.5;  // Less smoothing = more reactive
                analyser.minDecibels = -90;
                analyser.maxDecibels = -10;

                // Create audio effects chain
                filterNode = audioContext.createBiquadFilter();
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 20000;  // Start wide open
                filterNode.Q.value = 1;

                // Create delay/echo effect (subtle)
                delayNode = audioContext.createDelay(1.0);
                delayNode.delayTime.value = 0.15;  // 150ms delay

                feedbackGain = audioContext.createGain();
                feedbackGain.gain.value = 0;  // Start with no feedback

                wetGain = audioContext.createGain();
                wetGain.gain.value = 0;  // Start dry

                dryGain = audioContext.createGain();
                dryGain.gain.value = 1.0;  // Full dry signal

                // Only create source once
                if (!audioSetupComplete) {
                    source = audioContext.createMediaElementSource(audio);

                    // Connect audio chain:
                    // source -> filter -> split to dry/wet
                    // dry -> dryGain -> destination
                    // wet -> delay -> feedback -> delay (loop)
                    //     -> wetGain -> destination
                    source.connect(filterNode);
                    source.connect(analyser);  // Analyser gets unfiltered signal

                    // Dry path
                    filterNode.connect(dryGain);
                    dryGain.connect(audioContext.destination);

                    // Wet path (delay/echo)
                    filterNode.connect(delayNode);
                    delayNode.connect(feedbackGain);
                    feedbackGain.connect(delayNode);  // Feedback loop
                    delayNode.connect(wetGain);
                    wetGain.connect(audioContext.destination);

                    audioSetupComplete = true;
                }

                dataArray = new Uint8Array(analyser.frequencyBinCount);
            } catch (error) {
                console.error('Audio setup error:', error);
                alert('Audio setup failed. Please run this page from a local web server.\n\nRun: python3 -m http.server 8000\nThen open: http://localhost:8000');
            }
        }

        // Particle class
        class Particle {
            constructor() {
                // Spawn particles in expanded area for infinite feel (2x viewport)
                const expandedWidth = canvas.width * 2;
                const expandedHeight = canvas.height * 2;
                this.x = (Math.random() * expandedWidth) - expandedWidth / 4;
                this.baseX = this.x;
                this.y = (Math.random() * expandedHeight) - expandedHeight / 4;
                this.baseY = this.y;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.baseSize = 1 + Math.random() * 3;
                this.size = this.baseSize;

                // Assign color based on music profile
                this.hue = musicProfile.baseHue + (Math.random() - 0.5) * musicProfile.hueRange;
                this.saturation = 50 + Math.random() * 20;
                this.lightness = 50 + Math.random() * 30;
                this.brightness = 1;

                this.phase = Math.random() * Math.PI * 2;
                this.speed = musicProfile.particleSpeed * (0.5 + Math.random());

                // Assign frequency band (0: low, 1: mid, 2: high)
                this.frequencyBand = Math.floor(Math.random() * 3);
            }

            update(audioData, mouseX, mouseY) {
                // Get frequency data for this particle's band
                let bandIntensity = 0;
                if (this.frequencyBand === 0) {
                    bandIntensity = audioData.low;
                } else if (this.frequencyBand === 1) {
                    bandIntensity = audioData.mid;
                } else {
                    bandIntensity = audioData.high;
                }

                // Mouse attraction
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const mouseForce = Math.min(200, distance);
                const attractionStrength = (1 - mouseForce / 200) * 0.8;

                if (distance > 0) {
                    this.vx += (dx / distance) * attractionStrength * (0.5 + audioData.avg * 0.5);
                    this.vy += (dy / distance) * attractionStrength * (0.5 + audioData.avg * 0.5);
                }

                // Apply friction (adaptive to music tempo)
                this.vx *= musicProfile.particleFriction;
                this.vy *= musicProfile.particleFriction;

                // Update phase for sine wave motion - tempo-adaptive
                const audioMultiplier = analysisComplete ? (1 + audioData.avg * 5) : (1 + audioData.avg * 5);
                this.phase += this.speed * audioMultiplier;

                // HYPER-REACTIVE audio influence - 6x increase from 300 to 600
                const audioInfluence = bandIntensity * 600;

                // Graceful sine-wave floating with HYPER-REACTIVE audio response
                // Using different phase offsets to prevent directional bias
                this.x = this.baseX + Math.sin(this.phase) * (10 + audioInfluence * 0.8);  // Increased multiplier
                this.y = this.baseY + Math.sin(this.phase * 0.83 + Math.PI / 3) * (10 + audioInfluence * 1.2);  // Even more Y motion

                // Audio-influenced drift for base position - NO vertical bias
                this.baseX += this.vx;
                this.baseY += this.vy;

                // Expanded boundaries for infinite feel - wrap around at 2x viewport
                const expandedWidth = canvas.width * 2;
                const expandedHeight = canvas.height * 2;
                const margin = 50;

                // Wrap around horizontally
                if (this.baseX < -expandedWidth / 4 - margin) {
                    this.baseX = canvas.width + expandedWidth / 4 + margin;
                } else if (this.baseX > canvas.width + expandedWidth / 4 + margin) {
                    this.baseX = -expandedWidth / 4 - margin;
                }

                // Wrap around vertically
                if (this.baseY < -expandedHeight / 4 - margin) {
                    this.baseY = canvas.height + expandedHeight / 4 + margin;
                } else if (this.baseY > canvas.height + expandedHeight / 4 + margin) {
                    this.baseY = -expandedHeight / 4 - margin;
                }

                // Update size based on audio - HYPER-REACTIVE (doubled from 18 to 36)
                this.size = this.baseSize + bandIntensity * 36;

                // Update brightness with HYPER-REACTIVE dramatic changes
                if (audioData.avg > 0.2) {  // React earlier at 0.2 instead of 0.3
                    this.brightness = 2.5 + audioData.avg * 1.5; // Even bigger bursts
                } else {
                    this.brightness = 0.4 + audioData.avg * 2.0;  // Wider range
                }
            }

            draw(audioData) {
                // HYPER-REACTIVE alpha changes - wider range
                const alpha = 0.1 + audioData.avg * 0.9;  // 0.1 to 1.0 range

                // HYPER-REACTIVE lightness changes - capped lower to avoid whites
                let adjustedLightness = this.lightness;
                if (audioData.avg > 0.3) {  // React earlier
                    // Cap at 75% instead of 95% to avoid whites, favor saturated colors
                    adjustedLightness = Math.min(75, this.lightness + (audioData.avg - 0.3) * 80);
                }

                // DRAMATIC color shifts - emphasize REDS and GREENS on intensity
                let displayHue = this.hue;
                let displaySaturation = this.saturation;

                if (this.frequencyBand === 2 && audioData.high > 0.5) {
                    // High frequency particles: Blues/Greens -> Vibrant REDS
                    const highShift = (audioData.high - 0.5) * 2;  // 0.5->1.0 maps to 0->1
                    displayHue = this.hue * (1 - highShift) + (0 + Math.random() * 20) * highShift;  // Pure reds (0-20)
                    displaySaturation = Math.min(95, this.saturation + highShift * 50);  // Extremely saturated
                    adjustedLightness = Math.min(70, adjustedLightness + highShift * 20);  // Boost brightness but keep saturated
                } else if (audioData.avg > 0.5) {
                    // All particles shift colors more dramatically based on intensity
                    const intensityShift = (audioData.avg - 0.5) * 2;  // 0.5->1.0 maps to 0->1

                    if (audioData.avg > 0.7) {
                        // Very loud: shift to vibrant REDS (0-30 hue range)
                        displayHue = this.hue * (1 - intensityShift * 0.8) + (5 + Math.random() * 25) * intensityShift;
                        displaySaturation = Math.min(95, this.saturation + intensityShift * 45);
                    } else {
                        // Moderately loud: stay in blues/greens but boost GREEN tones
                        if (this.hue < 200) {
                            // Already green-ish, boost saturation and shift toward lime green (120)
                            displayHue = this.hue + intensityShift * 20;
                            displaySaturation = Math.min(90, this.saturation + intensityShift * 35);
                        } else {
                            // Blue-ish, shift slightly toward cyan/green
                            displayHue = this.hue - intensityShift * 30;
                            displaySaturation = Math.min(90, this.saturation + intensityShift * 30);
                        }
                    }
                }

                // Focus effect: Larger particles become sharper and more defined on loud audio
                const isFocused = this.size > 10 && audioData.avg > 0.5;
                const focusAmount = isFocused ? (audioData.avg - 0.5) * 2 : 0;  // 0 to 1

                // Sharper core on focused particles
                const coreAlpha = alpha * (1.5 + focusAmount * 0.8);
                const coreSize = this.size * (1 + focusAmount * 0.3);

                // Tighter, more defined glow for focused particles
                const glowSize = isFocused ? this.size * (3 - focusAmount * 0.8) : this.size * 4;

                // Draw glow (tighter when focused)
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, glowSize
                );
                gradient.addColorStop(0, `hsla(${displayHue}, ${displaySaturation}%, ${adjustedLightness}%, ${alpha})`);
                gradient.addColorStop(isFocused ? 0.6 : 1, `hsla(${displayHue}, ${displaySaturation}%, ${adjustedLightness}%, 0)`);

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowSize, 0, Math.PI * 2);
                ctx.fill();

                // Draw core particle - larger and brighter when focused
                ctx.fillStyle = `hsla(${displayHue}, ${displaySaturation + focusAmount * 10}%, ${adjustedLightness}%, ${coreAlpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, coreSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Particle array with dynamic sizing
        let particles = [];
        let baseParticleCount = 150;
        let targetParticleCount = baseParticleCount;

        function initParticles() {
            particles = [];
            for (let i = 0; i < baseParticleCount; i++) {
                particles.push(new Particle());
            }
        }

        // Spatial grid for detecting blank space
        const gridCellSize = 150;  // Size of each grid cell for density detection
        let densityCheckCounter = 0;  // Check density every N frames to reduce overhead

        // Analyze particle density and find blank areas
        function findBlankAreas() {
            const gridCols = Math.ceil(canvas.width / gridCellSize) + 2;  // +2 for margins
            const gridRows = Math.ceil(canvas.height / gridCellSize) + 2;
            const grid = Array(gridRows).fill(null).map(() => Array(gridCols).fill(0));

            // Count particles in each grid cell
            const allParticles = [...particles, ...userCreatedParticles];
            allParticles.forEach(p => {
                // Check if particle is visible on screen (accounting for current zoom)
                const screenX = p.x;
                const screenY = p.y;

                if (screenX >= -gridCellSize && screenX <= canvas.width + gridCellSize &&
                    screenY >= -gridCellSize && screenY <= canvas.height + gridCellSize) {

                    const col = Math.floor((screenX + gridCellSize) / gridCellSize);
                    const row = Math.floor((screenY + gridCellSize) / gridCellSize);

                    if (row >= 0 && row < gridRows && col >= 0 && col < gridCols) {
                        grid[row][col]++;
                    }
                }
            });

            // Find cells with low particle density (blank areas)
            const blankAreas = [];
            const minDensity = 2;  // Cells with fewer than 2 particles are "blank"

            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    if (grid[row][col] < minDensity) {
                        blankAreas.push({
                            x: col * gridCellSize - gridCellSize / 2 + Math.random() * gridCellSize,
                            y: row * gridCellSize - gridCellSize / 2 + Math.random() * gridCellSize
                        });
                    }
                }
            }

            return blankAreas;
        }

        // Dynamically adjust particle count based on zoom
        function updateParticleCount(zoom) {
            // When zoomed out (< 1.0), add more particles for infinite feel
            // When zoomed in (> 1.0), keep base count
            // Formula: zoom 0.5 = 300 particles, zoom 1.0 = 150, zoom 2.0 = 150
            if (zoom < 1.0) {
                targetParticleCount = Math.floor(baseParticleCount / zoom);
            } else {
                targetParticleCount = baseParticleCount;
            }

            // Check for blank spaces every 30 frames (about 2x per second)
            densityCheckCounter++;
            const shouldCheckDensity = zoom < 0.9 && densityCheckCounter % 30 === 0;

            const currentCount = particles.length + userCreatedParticles.length;

            if (currentCount < targetParticleCount) {
                let toAdd = Math.min(3, targetParticleCount - currentCount);  // Slower growth (3 instead of 5)

                // If zoomed out significantly, fill blank areas specifically
                if (shouldCheckDensity) {
                    const blankAreas = findBlankAreas();

                    if (blankAreas.length > 0) {
                        // Add 1-2 particles to random blank areas
                        toAdd = Math.min(2, toAdd, blankAreas.length);

                        for (let i = 0; i < toAdd; i++) {
                            const blank = blankAreas[Math.floor(Math.random() * blankAreas.length)];
                            const newParticle = new Particle();

                            // Override random position with blank area position
                            newParticle.x = blank.x;
                            newParticle.baseX = blank.x;
                            newParticle.y = blank.y;
                            newParticle.baseY = blank.y;

                            particles.push(newParticle);
                        }
                    } else {
                        // No blank areas found, add particles normally
                        for (let i = 0; i < toAdd; i++) {
                            particles.push(new Particle());
                        }
                    }
                } else {
                    // Normal particle addition
                    for (let i = 0; i < toAdd; i++) {
                        particles.push(new Particle());
                    }
                }
            } else if (particles.length > targetParticleCount) {
                // Remove excess base particles (not user-created)
                const toRemove = Math.min(3, particles.length - targetParticleCount);
                particles.splice(0, toRemove);
            }
        }

        // Music analysis history and profile
        let energyHistory = [];  // Track amplitude over time
        let spectralHistory = [];  // Track spectral characteristics
        let beatTimes = [];  // Track detected beats
        let previousAudioData = null;
        let musicProfile = {
            tempo: 90,  // BPM
            spectralCentroid: 2000,  // Hz
            spectralSpread: 1000,
            dynamicRange: 3.0,  // Crest factor
            density: 0.5,  // 0-1
            warmth: 0.5,  // 0-1 (low = dark/bass, high = bright/treble)
            particleFriction: 0.95,
            particleSpeed: 0.015,
            baseHue: 180,  // Base color
            hueRange: 60,  // Color palette range
            amplification: 7.0  // Audio reactivity multiplier
        };
        let analysisComplete = false;
        let analysisStartTime = 0;
        const ANALYSIS_DURATION = 30000;  // Analyze first 30 seconds

        // Get audio data with advanced analysis
        function getAudioData() {
            if (!analyser || !dataArray) {
                return { low: 0, mid: 0, high: 0, avg: 0, spectralCentroid: 0, spectralSpread: 0, onset: false };
            }

            analyser.getByteFrequencyData(dataArray);

            // Calculate band averages
            let low = 0, mid = 0, high = 0;
            const bufferLength = dataArray.length;

            // Low frequencies (bass) - first 10% of spectrum
            const lowEnd = Math.floor(bufferLength * 0.1);
            for (let i = 0; i < lowEnd; i++) {
                low += dataArray[i];
            }
            low = (low / lowEnd) / 255;

            // Mid frequencies - 10% to 40% of spectrum
            const midStart = lowEnd;
            const midEnd = Math.floor(bufferLength * 0.4);
            for (let i = midStart; i < midEnd; i++) {
                mid += dataArray[i];
            }
            mid = (mid / (midEnd - midStart)) / 255;

            // High frequencies - 40% to 70% of spectrum
            const highStart = midEnd;
            const highEnd = Math.floor(bufferLength * 0.7);
            for (let i = highStart; i < highEnd; i++) {
                high += dataArray[i];
            }
            high = (high / (highEnd - highStart)) / 255;

            // Overall average
            let sum = 0;
            for (let i = 0; i < highEnd; i++) {
                sum += dataArray[i];
            }
            const avg = (sum / highEnd) / 255;

            // SPECTRAL CENTROID (brightness)
            let weightedSum = 0;
            let magnitudeSum = 0;
            for (let i = 0; i < bufferLength; i++) {
                const frequency = (i * audioContext.sampleRate) / (analyser.fftSize * 2);
                weightedSum += frequency * dataArray[i];
                magnitudeSum += dataArray[i];
            }
            const spectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 2000;

            // SPECTRAL SPREAD (variance)
            let variance = 0;
            for (let i = 0; i < bufferLength; i++) {
                const frequency = (i * audioContext.sampleRate) / (analyser.fftSize * 2);
                variance += Math.pow(frequency - spectralCentroid, 2) * dataArray[i];
            }
            const spectralSpread = magnitudeSum > 0 ? Math.sqrt(variance / magnitudeSum) : 1000;

            // ONSET DETECTION (transients/hits)
            let onset = false;
            if (previousAudioData) {
                let spectralFlux = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const diff = Math.max(0, dataArray[i] - previousAudioData[i]);
                    spectralFlux += diff;
                }
                spectralFlux /= bufferLength;
                onset = spectralFlux > 20;  // Threshold for onset
            }
            previousAudioData = new Uint8Array(dataArray);

            // Adaptive amplification based on music profile
            const amplification = musicProfile.amplification;

            return {
                low: Math.min(1, low * amplification),
                mid: Math.min(1, mid * amplification),
                high: Math.min(1, high * amplification),
                avg: Math.min(1, avg * amplification),
                spectralCentroid,
                spectralSpread,
                onset
            };
        }

        // Analyze music character over time (first 30 seconds)
        function analyzeMusicProfile(audioData) {
            if (analysisComplete) return;

            const now = Date.now();
            if (analysisStartTime === 0) {
                analysisStartTime = now;
            }

            const elapsed = now - analysisStartTime;

            // Collect history
            energyHistory.push(audioData.avg);
            spectralHistory.push({
                centroid: audioData.spectralCentroid,
                spread: audioData.spectralSpread
            });

            // Detect beats
            if (audioData.onset && audioData.avg > 0.3) {
                beatTimes.push(now);
            }

            // After 30 seconds, calculate music profile
            if (elapsed >= ANALYSIS_DURATION && !analysisComplete) {
                analysisComplete = true;

                // TEMPO DETECTION (BPM)
                if (beatTimes.length > 10) {
                    const intervals = [];
                    for (let i = 1; i < Math.min(beatTimes.length, 50); i++) {
                        intervals.push(beatTimes[i] - beatTimes[i-1]);
                    }
                    intervals.sort((a, b) => a - b);
                    const medianInterval = intervals[Math.floor(intervals.length / 2)];
                    musicProfile.tempo = Math.round(60000 / medianInterval);
                    musicProfile.tempo = Math.max(60, Math.min(200, musicProfile.tempo));  // Clamp
                }

                // SPECTRAL CHARACTER
                const avgCentroid = spectralHistory.reduce((sum, s) => sum + s.centroid, 0) / spectralHistory.length;
                const avgSpread = spectralHistory.reduce((sum, s) => sum + s.spread, 0) / spectralHistory.length;
                musicProfile.spectralCentroid = avgCentroid;
                musicProfile.spectralSpread = avgSpread;

                // Warmth: 0 = dark/bass-heavy, 1 = bright/treble-heavy
                musicProfile.warmth = Math.min(1, avgCentroid / 4000);

                // DYNAMIC RANGE
                const peak = Math.max(...energyHistory);
                const rms = Math.sqrt(energyHistory.reduce((sum, e) => sum + e * e, 0) / energyHistory.length);
                musicProfile.dynamicRange = peak / (rms + 0.001);

                // DENSITY (spectral complexity)
                musicProfile.density = Math.min(1, avgSpread / 2000);

                // ADAPT VISUAL PARAMETERS
                adaptVisualsToMusic();

                console.log('Music Profile:', musicProfile);
            }
        }

        // Adapt visual parameters based on analyzed music profile
        function adaptVisualsToMusic() {
            // TEMPO → particle physics
            if (musicProfile.tempo > 140) {
                // Fast music (EDM, drum & bass)
                musicProfile.particleFriction = 0.88;  // Snappier
                musicProfile.particleSpeed = 0.03;  // Faster oscillation
                musicProfile.amplification = 9.0;  // More reactive
            } else if (musicProfile.tempo < 80) {
                // Slow music (ambient, ballad)
                musicProfile.particleFriction = 0.97;  // Smoother
                musicProfile.particleSpeed = 0.008;  // Slower oscillation
                musicProfile.amplification = 6.0;  // More subtle
            }

            // WARMTH → color palette
            if (musicProfile.warmth < 0.3) {
                // Dark/bass-heavy (hip-hop, dubstep)
                musicProfile.baseHue = 270;  // Purple base
                musicProfile.hueRange = 60;  // Purple to red
            } else if (musicProfile.warmth > 0.7) {
                // Bright/treble-heavy (pop, electronic)
                musicProfile.baseHue = 180;  // Cyan base
                musicProfile.hueRange = 80;  // Cyan to blue to magenta
            } else {
                // Balanced (rock, indie)
                musicProfile.baseHue = 200;  // Blue-green base
                musicProfile.hueRange = 100;
            }

            // DENSITY → particle count
            const densityMultiplier = 0.5 + musicProfile.density;
            baseParticleCount = Math.floor(150 * densityMultiplier);
            targetParticleCount = baseParticleCount;

            // DYNAMIC RANGE → zoom range
            // High dynamics = bigger zoom swings
            // (Will be applied in animation loop)

            console.log('Visuals adapted:', {
                tempo: musicProfile.tempo,
                warmth: musicProfile.warmth,
                particleCount: baseParticleCount,
                baseHue: musicProfile.baseHue
            });
        }

        // Draw connecting lines - HYPER-REACTIVE to audio
        function drawConnections(audioData) {
            const maxDistance = 80 + audioData.avg * 180; // Wider range: 80-260
            const lineAlpha = 0.05 + audioData.avg * 0.6; // Much more dramatic: 0.05-0.65

            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < maxDistance) {
                        const opacity = (1 - distance / maxDistance) * lineAlpha;
                        // Color shifts with audio - cyan to purple to red
                        const hue = audioData.avg > 0.5 ? 180 - (audioData.avg - 0.5) * 400 : 180;
                        ctx.strokeStyle = `hsla(${hue}, 60%, 60%, ${opacity})`;
                        ctx.lineWidth = 0.5 + audioData.avg * 4;  // Thicker lines on loud
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
        }

        // Draw and update click waves - DRAMATICALLY ENHANCED
        function updateClickWaves(audioData) {
            for (let i = clickWaves.length - 1; i >= 0; i--) {
                const wave = clickWaves[i];

                // Update wave - DRAMATIC expansion speed
                wave.radius += wave.speed * (2 + audioData.avg * 2.0);  // Much faster!
                wave.alpha -= wave.isPrimary ? 0.002 : 0.004;  // Primary wave lasts longer
                wave.age += 1;  // Increment age

                // Draw wave
                if (wave.alpha > 0) {
                    // Different visual style for void waves (destructive) vs additive waves
                    if (wave.isVoid) {
                        // Void wave: darker, reddish, ominous - DRAMATIC
                        const voidAlpha = wave.alpha * (0.5 + audioData.avg * 0.7);

                        // Outer ring - bright red
                        ctx.strokeStyle = `hsla(0, 80%, 55%, ${voidAlpha})`;
                        ctx.lineWidth = 5 + audioData.avg * 8;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Middle ring - dark red glow
                        ctx.strokeStyle = `hsla(340, 80%, 45%, ${voidAlpha * 0.7})`;
                        ctx.lineWidth = 12 + audioData.avg * 15;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Inner ring - deepest glow
                        ctx.strokeStyle = `hsla(0, 70%, 30%, ${voidAlpha * 0.4})`;
                        ctx.lineWidth = 20 + audioData.avg * 20;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        // Additive wave: DRAMATICALLY brighter and more ethereal
                        const addAlpha = wave.alpha * (0.4 + audioData.avg * 1.0);
                        const isPrimary = wave.isPrimary;

                        // Outer sharp ring - brilliant cyan
                        ctx.strokeStyle = `hsla(180, 90%, 75%, ${addAlpha * (isPrimary ? 1.2 : 0.8)})`;
                        ctx.lineWidth = (isPrimary ? 4 : 2) + audioData.avg * 8;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Middle glow ring - bright blue
                        ctx.strokeStyle = `hsla(200, 85%, 70%, ${addAlpha * (isPrimary ? 0.8 : 0.6)})`;
                        ctx.lineWidth = (isPrimary ? 10 : 7) + audioData.avg * 15;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Inner soft glow - ethereal teal
                        ctx.strokeStyle = `hsla(190, 75%, 65%, ${addAlpha * (isPrimary ? 0.5 : 0.3)})`;
                        ctx.lineWidth = (isPrimary ? 18 : 12) + audioData.avg * 25;
                        ctx.beginPath();
                        ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Radial flash at center (only for primary wave when young)
                        if (isPrimary && wave.age < 20) {
                            const flashAlpha = (1 - wave.age / 20) * addAlpha * 0.8;
                            const flashGradient = ctx.createRadialGradient(
                                wave.x, wave.y, 0,
                                wave.x, wave.y, wave.radius * 0.3
                            );
                            flashGradient.addColorStop(0, `hsla(180, 100%, 85%, ${flashAlpha})`);
                            flashGradient.addColorStop(1, `hsla(180, 100%, 85%, 0)`);
                            ctx.fillStyle = flashGradient;
                            ctx.beginPath();
                            ctx.arc(wave.x, wave.y, wave.radius * 0.3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // DRAMATIC particle interaction - much stronger forces
                    const allParticles = [...particles, ...userCreatedParticles];
                    allParticles.forEach(particle => {
                        const dx = particle.baseX - wave.x;  // Direction away from wave center
                        const dy = particle.baseY - wave.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        // MUCH wider interaction band for dramatic effect
                        const interactionBand = wave.isPrimary ? 200 : 150;
                        if (Math.abs(dist - wave.radius) < interactionBand) {
                            const proximity = (interactionBand - Math.abs(dist - wave.radius)) / interactionBand;

                            // Phase 1: VERY strong repel for first 60 frames
                            // Phase 2: Stronger pull back after that
                            let forceDirection = 1; // 1 = repel, -1 = attract
                            let forceMagnitude = 0;

                            if (wave.age < 60) {
                                // Initial repel phase - MUCH stronger push
                                forceDirection = 1;
                                forceMagnitude = proximity * (wave.isPrimary ? 3.5 : 2.0);  // 3x stronger!
                            } else {
                                // Ebb back phase - stronger pull
                                forceDirection = -1;
                                const ebbProgress = Math.min((wave.age - 60) / 120, 1);
                                forceMagnitude = proximity * 0.8 * ebbProgress;  // 2.5x stronger pull
                            }

                            if (dist > 0) {
                                particle.vx += (dx / dist) * forceDirection * forceMagnitude;
                                particle.vy += (dy / dist) * forceDirection * forceMagnitude;
                            }
                        }
                    });
                }

                // Remove dead waves
                if (wave.alpha <= 0 || wave.radius > wave.maxRadius) {
                    clickWaves.splice(i, 1);
                }
            }
        }

        // Trigger spooky "sunday" memory flashback - letters fade in/out one at a time
        async function triggerSundayMemory() {
            if (isFlashbackActive) return;
            isFlashbackActive = true;

            // Make sunday text container visible but letters start at opacity 0
            sundayText.style.opacity = '1';
            sundayText.style.pointerEvents = 'none';

            // Fade IN letters one at a time
            for (let i = 0; i < sundayLetters.length; i++) {
                sundayLetters[i].style.opacity = '1';
                await new Promise(resolve => setTimeout(resolve, 200 + Math.random() * 300)); // 200-500ms between letters
            }

            // Hold for a moment (2-3 seconds)
            await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 1000));

            // Fade OUT letters one at a time (random order for spookiness)
            const fadeOutOrder = [0, 1, 2, 3, 4, 5].sort(() => Math.random() - 0.5);
            for (let i = 0; i < fadeOutOrder.length; i++) {
                sundayLetters[fadeOutOrder[i]].style.opacity = '0';
                await new Promise(resolve => setTimeout(resolve, 150 + Math.random() * 250)); // 150-400ms between letters
            }

            isFlashbackActive = false;
        }

        // Update progress bar
        function updateProgress() {
            if (audio.duration) {
                const progress = (audio.currentTime / audio.duration) * 100;
                progressFill.style.width = progress + '%';

                // Keep subtle pulsing, increase opacity on hover
                const mouseNearBottom = mouseY > canvas.height - 100;
                if (mouseNearBottom) {
                    progressBar.style.opacity = '0.6';
                    progressBar.style.animation = 'none';
                } else {
                    progressBar.style.opacity = '';
                    progressBar.style.animation = '';
                }
            }
        }

        // Check for memory flashback triggers based on music progress
        function checkSundayMemory() {
            if (!audio.duration || isFlashbackActive) return;

            const progress = audio.currentTime / audio.duration;

            // Define 2-3 trigger points with some randomness (30%, 55%, 80% through song)
            const triggers = [
                { time: 0.15 + Math.random() * 0.04, id: 1 },
                { time: 0.45 + Math.random() * 0.04, id: 2 },
                { time: 0.75 + Math.random() * 0.04, id: 3 }
            ];

            // Check if we've passed any trigger points
            for (const trigger of triggers) {
                if (progress >= trigger.time && !sundayMemoryTriggered.includes(trigger.id)) {
                    sundayMemoryTriggered.push(trigger.id);
                    triggerSundayMemory();
                    break;  // Only trigger one at a time
                }
            }
        }

        // Zoom variables
        let currentZoom = 1.0;
        let targetZoom = 1.0;
        let manualZoom = 1.0;  // User-controlled zoom via mouse wheel
        let clickZoomPulse = 1.0;  // Temporary zoom pulse from clicks

        // Mouse wheel handler
        window.addEventListener('wheel', (e) => {
            resetAutoPilot();  // User interaction detected
            e.preventDefault();

            // Adjust manual zoom with WIDER range for infinite feel (0.3x to 3.0x)
            const zoomDelta = e.deltaY * -0.001;
            manualZoom = Math.max(0.3, Math.min(3.0, manualZoom + zoomDelta));
        }, { passive: false });

        // Onset burst particles
        let onsetBurstParticles = [];

        // Create particle burst on transient/hit
        function createOnsetBurst(audioData) {
            if (!audioData.onset) return;

            // Create 5-15 particles from center
            const burstCount = 5 + Math.floor(Math.random() * 10);
            for (let i = 0; i < burstCount; i++) {
                const angle = (Math.PI * 2 * i) / burstCount + Math.random() * 0.3;
                const speed = 3 + Math.random() * 5;

                onsetBurstParticles.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    hue: musicProfile.baseHue + (Math.random() - 0.5) * musicProfile.hueRange,
                    size: 2 + Math.random() * 4
                });
            }
        }

        // Update onset burst particles
        function updateOnsetBursts() {
            for (let i = onsetBurstParticles.length - 1; i >= 0; i--) {
                const p = onsetBurstParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;  // Friction
                p.vy *= 0.98;
                p.life -= 0.02;

                if (p.life > 0) {
                    const alpha = p.life * 0.8;
                    ctx.fillStyle = `hsla(${p.hue}, 80%, 65%, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    onsetBurstParticles.splice(i, 1);
                }
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update auto-pilot system
            updateAutoPilot();

            // Get audio data FIRST
            const audioData = getAudioData();

            // Analyze music character (first 30 seconds)
            analyzeMusicProfile(audioData);

            // Create onset bursts on hits
            createOnsetBurst(audioData);

            // Trail effect - HYPER-REACTIVE background fade
            // Faster fade on loud (more energy = clearer visuals), slower on quiet (more trails)
            const trailFade = 0.08 + audioData.avg * 0.25;  // 0.08 to 0.33
            ctx.fillStyle = `rgba(10, 15, 25, ${trailFade})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate zoom based on audio intensity - adaptive to dynamic range
            // High dynamic range music = bigger swings
            const zoomRange = analysisComplete ? (0.3 + musicProfile.dynamicRange * 0.2) : 1.1;
            const zoomMin = analysisComplete ? (0.6 - zoomRange * 0.2) : 0.5;
            const audioZoom = zoomMin + audioData.avg * zoomRange;

            // Decay click zoom pulse back to 1.0
            clickZoomPulse += (1.0 - clickZoomPulse) * 0.08;  // Smooth decay

            // Combine manual zoom, audio zoom, and click pulse
            targetZoom = manualZoom * audioZoom * clickZoomPulse;

            // HYPER-REACTIVE zoom transition - faster response
            currentZoom += (targetZoom - currentZoom) * 0.25;  // 0.25 instead of 0.1

            // Update particle count based on zoom for infinite feel
            updateParticleCount(currentZoom);

            // Save canvas state
            ctx.save();

            // Apply zoom transform from center
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(currentZoom, currentZoom);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);

            // Update progress bar
            updateProgress();

            // Check for sunday memory flashbacks
            checkSundayMemory();

            // Draw and update click waves
            updateClickWaves(audioData);

            // Draw connections
            drawConnections(audioData);

            // Update and draw particles with mouse position
            particles.forEach(particle => {
                particle.update(audioData, mouseX, mouseY);
                particle.draw(audioData);
            });

            // Update and draw user-created particles (they also react to audio)
            for (let i = userCreatedParticles.length - 1; i >= 0; i--) {
                const particle = userCreatedParticles[i];
                particle.update(audioData, mouseX, mouseY);
                particle.draw(audioData);

                // PERMANENT particles never fade - only remove non-permanent ones
                if (!particle.permanent) {
                    const age = Date.now() - particle.birthTime;
                    if (age > 60000) {  // 60 seconds instead of 30
                        userCreatedParticles.splice(i, 1);
                    }
                }
            }

            // Draw onset burst particles (inside zoom transform)
            updateOnsetBursts();

            // Update and draw mouse trail - HYPER-REACTIVE to audio with SLOW decay
            for (let i = mouseTrail.length - 1; i >= 0; i--) {
                const trail = mouseTrail[i];
                trail.life -= 0.003;  // MUCH slower decay (was 0.01)

                if (trail.life > 0) {
                    // HYPER-REACTIVE sizing - pulse with audio
                    const audioPulse = 1 + audioData.avg * 1.5;  // 1x to 2.5x size
                    const trailSize = 8 * trail.life * audioPulse;
                    const coreSize = 2 * trail.life * audioPulse;

                    // Draw trail point with fading glow
                    const gradient = ctx.createRadialGradient(
                        trail.x, trail.y, 0,
                        trail.x, trail.y, trailSize
                    );
                    // HYPER-REACTIVE brightness
                    const trailAlpha = trail.life * (0.3 + audioData.avg * 0.5);
                    gradient.addColorStop(0, `hsla(${trail.hue}, 70%, 60%, ${trailAlpha})`);
                    gradient.addColorStop(1, `hsla(${trail.hue}, 70%, 60%, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, trailSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw small core - brighter on loud
                    const coreAlpha = trail.life * (0.5 + audioData.avg * 0.8);
                    ctx.fillStyle = `hsla(${trail.hue}, 80%, 70%, ${coreAlpha})`;
                    ctx.beginPath();
                    ctx.arc(trail.x, trail.y, coreSize, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    mouseTrail.splice(i, 1);
                }
            }

            // Draw subtle audio effect indicators (outside zoom transform)
            ctx.restore();

            // Visual feedback for filter sweep (subtle gradient at edges)
            if (filterNode && audioContext) {
                const filterNormalized = (filterNode.frequency.value - 200) / 19800;  // 0 to 1

                // Top glow = high frequencies (bright)
                const topGlow = ctx.createLinearGradient(0, 0, 0, 50);
                topGlow.addColorStop(0, `rgba(100, 200, 255, ${filterNormalized * 0.15})`);
                topGlow.addColorStop(1, 'rgba(100, 200, 255, 0)');
                ctx.fillStyle = topGlow;
                ctx.fillRect(0, 0, canvas.width, 50);

                // Bottom glow = low frequencies (warm)
                const bottomGlow = ctx.createLinearGradient(0, canvas.height - 50, 0, canvas.height);
                bottomGlow.addColorStop(0, 'rgba(255, 100, 80, 0)');
                bottomGlow.addColorStop(1, `rgba(255, 100, 80, ${(1 - filterNormalized) * 0.15})`);
                ctx.fillStyle = bottomGlow;
                ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

                // Right glow = echo/delay (ethereal cyan)
                if (wetGain) {
                    const delayAmount = wetGain.gain.value / 0.25;  // 0 to 1
                    const rightGlow = ctx.createLinearGradient(canvas.width - 80, 0, canvas.width, 0);
                    rightGlow.addColorStop(0, 'rgba(80, 255, 200, 0)');
                    rightGlow.addColorStop(1, `rgba(80, 255, 200, ${delayAmount * 0.2})`);
                    ctx.fillStyle = rightGlow;
                    ctx.fillRect(canvas.width - 80, 0, 80, canvas.height);
                }
            }

            // Decay mouse influence
            mouseInfluence *= 0.95;
        }

        // Auto-pilot system - simulates natural user gestures when idle
        function updateAutoPilot() {
            const now = Date.now();
            const timeSinceInteraction = now - lastUserInteraction;

            // Enable auto-pilot after idle timeout
            if (!autoPilotActive && timeSinceInteraction > IDLE_TIMEOUT && started) {
                autoPilotActive = true;
                startNewAutoPilotGesture();
            }

            // Execute current auto-pilot gesture
            if (autoPilotActive && autoPilotState.gesture) {
                const elapsed = now - autoPilotState.startTime;
                const progress = Math.min(1, elapsed / autoPilotState.duration);

                switch (autoPilotState.gesture) {
                    case 'smooth-move':
                        // Smooth mouse movement with easing
                        const eased = 1 - Math.pow(1 - progress, 3);  // Ease out cubic
                        mouseX = autoPilotState.startX + (autoPilotState.targetX - autoPilotState.startX) * eased;
                        mouseY = autoPilotState.startY + (autoPilotState.targetY - autoPilotState.startY) * eased;

                        // Simulate filter/delay changes
                        if (filterNode && audioContext) {
                            const filterFreq = 20000 - (mouseY / canvas.height) * 19800 + 200;
                            filterNode.frequency.setTargetAtTime(filterFreq, audioContext.currentTime, 0.05);
                            const delayMix = (mouseX / canvas.width) * 0.25;
                            const feedback = (mouseX / canvas.width) * 0.35;
                            if (wetGain && feedbackGain) {
                                wetGain.gain.setTargetAtTime(delayMix, audioContext.currentTime, 0.1);
                                feedbackGain.gain.setTargetAtTime(feedback, audioContext.currentTime, 0.1);
                            }
                        }
                        break;

                    case 'circular-move':
                        // Circular mouse motion
                        const angle = progress * Math.PI * 2;
                        const radius = 150 + Math.sin(progress * Math.PI * 4) * 50;
                        mouseX = autoPilotState.startX + Math.cos(angle) * radius;
                        mouseY = autoPilotState.startY + Math.sin(angle) * radius;

                        // Audio effects
                        if (filterNode && audioContext) {
                            const filterFreq = 20000 - (mouseY / canvas.height) * 19800 + 200;
                            filterNode.frequency.setTargetAtTime(filterFreq, audioContext.currentTime, 0.05);
                            const delayMix = (mouseX / canvas.width) * 0.25;
                            const feedback = (mouseX / canvas.width) * 0.35;
                            if (wetGain && feedbackGain) {
                                wetGain.gain.setTargetAtTime(delayMix, audioContext.currentTime, 0.1);
                                feedbackGain.gain.setTargetAtTime(feedback, audioContext.currentTime, 0.1);
                            }
                        }
                        break;

                    case 'drag-paint':
                        // Simulate drag painting
                        isDragging = true;
                        const dragEased = progress < 0.5 ? 2 * progress : 2 - 2 * progress;  // Ease in-out
                        mouseX = autoPilotState.startX + (autoPilotState.targetX - autoPilotState.startX) * progress;
                        mouseY = autoPilotState.startY + (autoPilotState.targetY - autoPilotState.startY) * dragEased;

                        // Create particles
                        if (Math.random() < 0.5) {
                            const newParticle = new Particle();
                            newParticle.x = mouseX + (Math.random() - 0.5) * 20;
                            newParticle.baseX = newParticle.x;
                            newParticle.y = mouseY + (Math.random() - 0.5) * 20;
                            newParticle.baseY = newParticle.y;
                            newParticle.userCreated = true;
                            newParticle.permanent = true;
                            newParticle.birthTime = Date.now();
                            userCreatedParticles.push(newParticle);
                        }

                        // Trail
                        if (Math.random() < 0.25) {
                            mouseTrail.push({
                                x: mouseX,
                                y: mouseY,
                                life: 2.0,
                                hue: 180 + Math.random() * 40,
                                createdAt: Date.now()
                            });
                        }
                        break;

                    case 'click':
                        // Already executed at start, just wait for duration
                        break;

                    case 'zoom':
                        // Simulate scroll zoom
                        const zoomProgress = Math.sin(progress * Math.PI);  // Smooth zoom in and out
                        manualZoom = 1.0 + zoomProgress * 0.8;  // Zoom from 1.0 to 1.8 and back
                        break;

                    case 'figure-eight':
                        // Figure-8 pattern (infinity symbol)
                        const t = progress * Math.PI * 2;
                        const scale = 200;
                        mouseX = autoPilotState.startX + scale * Math.sin(t);
                        mouseY = autoPilotState.startY + scale * Math.sin(t) * Math.cos(t);

                        // Audio effects
                        if (filterNode && audioContext) {
                            const filterFreq = 20000 - (mouseY / canvas.height) * 19800 + 200;
                            filterNode.frequency.setTargetAtTime(filterFreq, audioContext.currentTime, 0.05);
                            const delayMix = (mouseX / canvas.width) * 0.25;
                            const feedback = (mouseX / canvas.width) * 0.35;
                            if (wetGain && feedbackGain) {
                                wetGain.gain.setTargetAtTime(delayMix, audioContext.currentTime, 0.1);
                                feedbackGain.gain.setTargetAtTime(feedback, audioContext.currentTime, 0.1);
                            }
                        }
                        break;
                }

                // Check if gesture is complete
                if (progress >= 1) {
                    // Stop dragging if needed
                    if (autoPilotState.gesture === 'drag-paint') {
                        isDragging = false;
                    }

                    // Wait 1-3 seconds before next gesture
                    const waitTime = 1000 + Math.random() * 2000;
                    setTimeout(() => {
                        if (autoPilotActive) {
                            startNewAutoPilotGesture();
                        }
                    }, waitTime);

                    autoPilotState.gesture = null;
                }
            }
        }

        // Start a new random auto-pilot gesture
        function startNewAutoPilotGesture() {
            const gestures = ['smooth-move', 'circular-move', 'drag-paint', 'click', 'zoom', 'figure-eight'];
            const gesture = gestures[Math.floor(Math.random() * gestures.length)];

            const now = Date.now();
            autoPilotState.startTime = now;
            autoPilotState.gesture = gesture;
            autoPilotState.startX = mouseX;
            autoPilotState.startY = mouseY;

            // Generate target based on gesture type
            switch (gesture) {
                case 'smooth-move':
                    autoPilotState.targetX = Math.random() * canvas.width;
                    autoPilotState.targetY = Math.random() * canvas.height;
                    autoPilotState.duration = 3000 + Math.random() * 3000;  // 3-6 seconds
                    break;

                case 'circular-move':
                    autoPilotState.targetX = canvas.width / 2 + (Math.random() - 0.5) * canvas.width * 0.5;
                    autoPilotState.targetY = canvas.height / 2 + (Math.random() - 0.5) * canvas.height * 0.5;
                    autoPilotState.duration = 4000 + Math.random() * 3000;  // 4-7 seconds
                    break;

                case 'drag-paint':
                    autoPilotState.targetX = Math.random() * canvas.width;
                    autoPilotState.targetY = Math.random() * canvas.height;
                    autoPilotState.duration = 2000 + Math.random() * 2000;  // 2-4 seconds
                    break;

                case 'click':
                    // Execute click immediately
                    autoPilotState.targetX = mouseX;
                    autoPilotState.targetY = mouseY;
                    autoPilotState.duration = 100;  // Very short

                    // Simulate click event
                    clickWaves.push({
                        x: mouseX,
                        y: mouseY,
                        radius: 0,
                        maxRadius: 800 + Math.random() * 400,
                        alpha: 1.5,
                        speed: 1.2 + Math.random() * 0.8,
                        age: 0,
                        isVoid: false,
                        isPrimary: true
                    });

                    setTimeout(() => {
                        clickWaves.push({
                            x: mouseX,
                            y: mouseY,
                            radius: 0,
                            maxRadius: 600 + Math.random() * 300,
                            alpha: 1.0,
                            speed: 0.8 + Math.random() * 0.4,
                            age: 0,
                            isVoid: false,
                            isPrimary: false
                        });
                    }, 150);

                    setTimeout(() => {
                        clickWaves.push({
                            x: mouseX,
                            y: mouseY,
                            radius: 0,
                            maxRadius: 400 + Math.random() * 200,
                            alpha: 0.8,
                            speed: 0.5 + Math.random() * 0.3,
                            age: 0,
                            isVoid: false,
                            isPrimary: false
                        });
                    }, 300);

                    clickZoomPulse = 1.15;
                    break;

                case 'zoom':
                    autoPilotState.duration = 5000 + Math.random() * 3000;  // 5-8 seconds
                    break;

                case 'figure-eight':
                    autoPilotState.targetX = canvas.width / 2;
                    autoPilotState.targetY = canvas.height / 2;
                    autoPilotState.duration = 6000 + Math.random() * 2000;  // 6-8 seconds
                    break;
            }
        }

        // Reset auto-pilot when user interacts
        function resetAutoPilot() {
            lastUserInteraction = Date.now();
            if (autoPilotActive) {
                autoPilotActive = false;
                autoPilotState.gesture = null;
                isDragging = false;
                manualZoom = 1.0;  // Reset zoom to default
            }
        }

        // Start on user interaction
        let started = false;

        async function startVisualization() {
            if (started) return;
            started = true;

            // Hide overlay
            clickOverlay.classList.add('hidden');

            // Fade out sunday text and all instructions
            setTimeout(() => {
                sundayText.classList.add('fadeOut');
                instructions.forEach(inst => inst.classList.add('fadeOut'));

                // After fade out, reset letters to hidden state for memory flashbacks
                setTimeout(() => {
                    sundayText.classList.remove('fadeOut');
                    sundayLetters.forEach(letter => letter.style.opacity = '0');
                }, 2000);
            }, 500);

            setupAudio();
            initParticles();

            // Resume audio context if suspended (should work now after user gesture)
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            try {
                await audio.play();
                animate();
            } catch (error) {
                console.error('Failed to start audio:', error);
            }
        }

        // Start on click anywhere
        clickOverlay.addEventListener('click', startVisualization);
        document.addEventListener('keydown', startVisualization, { once: true });
    </script>
</body>
</html>
